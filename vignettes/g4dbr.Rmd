---
title: "g4dbr"
author: 'Eric Largy'
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    toc_depth: '3'
bibliography: bibliography.bibtex
csl: american-chemical-society.csl
vignette: >
  %\VignetteIndexEntry{g4dbr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
  ```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

> *Copyright 2020 [Eric Largy](https://github.com/EricLarG4). Licensed under the GPL-3 license.*

# General overview

## Intended and less-intended uses

*g4dbr* is an R package containing the Shiny app *g4db* that is dedicated to the <ins>creation</ins>, <ins>vizualisation</ins>, and <ins>reporting</ins> of curated circular dichroism (CD), ^1^H-NMR, UV-melting and native mass spectrometry (MS) data from oligonucleotides. Although specifically developed for G-quadruplex forming sequences deposited on the PDB, *g4dbr* can be used with any sequence.

Users can either employ the app to visualize a database generated by *g4db*, visualize data pasted into a templated Excel file (provided in the package), and create/edit/complete a *g4db* database from data supplied in said template.

The long-term goal is to provide tools for the robust **deposition** of raw experimental data, and processed data derived from them, while allowing for easy and versatile visualisation and reporting. 

Raw data pasted in the supplied Excel template can be deposited, and visualized in several ways, which are open to other scientists without the need for proprietary software. The approach is two-fold:

### Templated .xlsx file deposition as is

Once pasted into the input template, the data can be deposited as is. It can then be explored natively in Excel or any open-source equivalent. The data is formatted in a non-ambiguous layout, provided it is properly labelled in the header cells. 

The template is also very amenable to pieces of software allowing header cell import/management, such as Origin, in which import scripts can be used.

Of course, the template can be natively imported in the *g4db* app. The advantages over Excel/Origin for this particular application are numerous in terms of both ease and speed of use (data filtering, automated figures, etc.), and functionalities (peak labelling, normalisation/calculation, selective data export, etc.). See the _Main features_ section for more details.

Any data treatment and filtering perfomed within *g4db* is not saved into the .xlsx file. To save this into a new or existing database file, the second approach must be used:

### .Rda file

*g4db* allows exporting selected datasets into an .Rda file where the data is consolidated and all calculation has already been performed. This leads to faster figure display, smaller file size, and is amenable to host very large dataset (where Excel is limited in row numbers).

The downside of this approach is that it cannot be handled outside of R. Note, however, that *g4db* is not required to open and use the data, it can be natively loaded in R using the `load` function, for instance below for a demo database provided in the package:

```{r load.demo.db, eval=FALSE, include=TRUE}
load(system.file("extdata/demo_database.Rda", package = 'g4dbr'))
```

## Extended scope

*g4dbr* includes a number of functionalities that will be described here within the context of their intended use, but that can be utilized outside of this scope, *i.e.* 

+ automated or semi-automated data filtering, treatment and labelling, 
+ computation of molar extinction coefficient ($\lambda$ = 260 nm) of oligonucleotides (*epsilon.calculator*),
+ UV-melting data treatment (*meltR*),
+ MS data size reduction

## Main features

Below is a list of the main features of *g4dbr*.

+ Vizualisation of CD, UV-melting, ^1^H-NMR and native MS data gathered in a database (.Rda format)
  + Collapsible and tabulated interface
  + Quick and user-friendly data filtering in tables and figures (*e.g.* oligonucleotide, buffer, cation, x-axis range,...)
    + Automated buffer list collection
    + Automated tune and replicate collection
  + Control over the database content, display, and reporting (see below)
+ Robust database creation and edition
  + Data imported from a templated Excel files
  + Selective data importing (by *e.g.* technique/oligo/buffer/data range) 
  + Duplicate detection/suppression
  + Automated deposition date and DOI link generation for traceability purpose
  + Manages replication for MS and UV-melting data
  + Manages tuning for MS data
+ Automated data treatment
  + Conversion of CD to molar ellipticities
  + MS data normalization
  + ^1^H-NMR and MS peak labelling
  + UV-melting data normalization and conversion to folded fraction
+ Custom figures
  + Control over colors, size, and transparency of figures
  + Color palettes adapted to qualitative, sequential, and diverging data
  + Switch between overlaid and paneled figures for quick comparisons
  + Control over variables mapped in paneled figures
  + Automated colour mapping to non-paneled variables
  + Automated figure dimension change to accomodate multiple rows
+ Automated report generation
  + pdf, HTML and Word formats can be selected
  + All data, figure captions, figure sizing, file name, etc. are generated dynamically without user input
+ Open
  + Easy-to-export data tables (practical for standalone data treatment)
  + Import template easy to read in other software

# Installation and setup

## Installation

Install from Github using:

```{r install_online, eval=FALSE, include=TRUE}
install.packages("devtools")
devtools::install_github('g4db-team/g4dbr', build_vignettes = T, build_manual = T)
```

Alternatively, download the .zip archive from GitHub then run:

```{r install, eval=FALSE, include=TRUE}
install.packages("devtools")
devtools::install_local("XXX/g4dbr-master.zip")
```

Where `XXX` is the filepath of the zip archive.

## Setup

Load the package with:

```{r setup}
library(g4dbr)
```

# *g4db*

## Running the app

Only one function must be called to use all functionalities from *g4dbr*:

```{r running, eval=FALSE, include=TRUE}
g4db()
```

This function opens a Shiny app in either the currently used IDE, or a web browser.

## Interface overview

The interface is divided in 3 tabs that can be selected at the top of the screen, and are used to accomplished specific tasks:

+ _database_, to visualize, report, and remove data from a database file.
+ _importR_, to visualize and process raw data, and export all or part of it to a database file,
+ _meltR_, to visualize and treat UV-melting data, and export all or part of it to the a database (via _importR_),

### database

This tab contain all *intended* end-user functionalities, that is 

### importR

### meltR

## Consulting a database

### Database architecture

The data from a given database is gathered in a single .Rda file that contains five dataframes: one dedicated to the general oligonucleotide information (`db.info`), and the four other ones to each analytical technique (`db.CD`, `db.NMR`, `db.MS`, `db.UV`). 

*g4db* extracts automatically all the data, but it can also be loaded in the global environment (*i.e.* without using *g4db*) using `load()`. For instance, to load the demo database, run:

```{r load.demo.db.2, eval=FALSE, include=TRUE}
load(system.file("extdata/demo_database.Rda", package = 'g4dbr'))
```

The global environment should now contain five dataframes that can be opended and worked with.

## Importing data

### Templated-Excel file

# Other functions and reference files

## epsilon.calculator

### Principles

`epsilon.calculator` relies on the 'traditional' format of the nearest-neighbor model for extinction coefficient calculation, applied at 260 nm.[@Cantor1970; @Tataurov2008]

$$\epsilon_{260nm} = \sum_{i=1}^{N_b - 1}\epsilon_{i, i+1} - \sum_{i=2}^{N_b - 1}\epsilon_{i}$$

To that effect, it uses `epsilondb`, a database of reference $\epsilon_{260 nm}$ contributions from the individual nucleobases, and couples of nucleobases (neighboring effects):

```{r epsilon.db}
epsilondb
```

epsilon.db is contained within the `[installpath]/data/Rdata.rds` file after the package is built. The value may be modified from the `[installpath]/extdata/referencedb.xlsx` but requires to rebuild the package.

### Code

The code of `epsilon.calculator` is contained in `R/EpsilonCalc.R`

First, the list of nucleobases and their nearest 3' neighbour are extracted from the user-supplied sequence (here 5'-GCAT-3'):

```{r sequence.read}
library(stringr)
library(tidyverse)

#sequence provided by the user
sequence <- 'GCAT'

#initialization of result data frame
epsilon.calc <- data.frame()
buffer <- data.frame()
result <- data.frame()

#extraction of individual bases and their 3' nearest neighbor
for (i in 1:str_length(sequence)) {
  buffer <- data.frame(position = i,
                       nucleo = substr(sequence, i, i),
                       nn = substr(sequence, i+1, i+1)
  )
  epsilon.calc <- rbind(epsilon.calc, buffer)
}

epsilon.calc
```

Their contribution are then attributed by matching their one letter code to the database, and both the 5' and 3' ends have their individual contributions set to zero.

```{r contribution}
#attribution of individual and nearest neighbor contributions
  epsilon.calc <- epsilon.calc %>%
    mutate(
      indiv.base.cont = case_when( #individual
        nucleo == 'G' ~ epsilondb$epsilon[epsilondb$base == 'G'],
        nucleo == 'C' ~ epsilondb$epsilon[epsilondb$base == 'C'],
        nucleo == 'T' ~ epsilondb$epsilon[epsilondb$base == 'T'],
        nucleo == 'A' ~ epsilondb$epsilon[epsilondb$base == 'A']
      ),
      nn.cont = case_when( #nearest neighbor
        nucleo == 'G' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'G'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'G'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'G'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'G']
        ),
        nucleo == 'C' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'C'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'C'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'C'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'C']
        ),
        nucleo == 'T' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'T'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'T'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'T'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'T']
        ),
        nucleo == 'A' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'A'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'A'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'A'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'A']
        )
      )
    )

  epsilon.calc$indiv.base.cont[1] = 0 #attributes 0 to the first nucleobase individual contribution
  epsilon.calc$indiv.base.cont[str_length(sequence)] = 0 #attributes 0 to the last nucleobase individual contribution

epsilon.calc
```

Finally, the sum of individual contributions are subtracted from the nearest neighbor contributions:

```{r result.epsilon}
#sum of indiv cont subtracted from sum of nn cont.
result <- sum(epsilon.calc$nn.cont, na.rm = T) - sum(epsilon.calc$indiv.base.cont, na.rm = T)
result
```


### Use

`epsilon.calculator` computes the molar extinction coefficient at 260 nm of oligonucleotides from their sequences. So far, it only works for DNA oligonucleotides, using the four canonical nucleotides.

Below is an example for a single sequence:

```{r eps.DNA}
epsilon.calculator("GGGTTAGGGTTAGGGTTAGGG")
```

The sequence must be provided as a string, and **must** be written with upper case letters (to allow the implementation of RNA calculation in the future):

```{r eps.RNA}
epsilon.calculator("gggttagggttagggttaggg")
```

`epsilon.calculator` can be applied on a list of sequence (here, `oligo.list`) using the base function `lapply`:

```{r eps.list}
oligo.list <- c('oligo name 1' = 'GGGTTAGGGTTAGGGTTAGGG', 'oligo name 2' = 'TGGGGT', 'oligo name 3' = 'GCAT', 'oligo name 4' = 'TACG')

epsilon.list <- lapply(oligo.list, epsilon.calculator)

epsilon.list
```

or on a data frame (here, `df`) to directly associate the results to other variables, as is performed within `g4db`.

```{r eps.df}
df <- data.frame(
  oligo = c('name 1', 'name 2', 'name 3', 'name 4'),
  something = c('a', 'b', 'c', 'd'),
  sequence = c('GGGTTAGGGTTAGGGTTAGGG', 'TGGGGT', 'GCAT', 'TACG')
)

df$epsilon <- lapply(df$sequence, epsilon.calculator)

df
```






# References



