---
title: "g4dbr"
author: 'Eric Largy'
date: "`r Sys.Date()`"
output:
    bookdown::html_document2:
      base_format: rmarkdown::html_vignette
      toc: true
      number_sections: true
      toc_depth: '3'
      fig_caption: true
link-citations: yes
bibliography: bibliography.bibtex
csl: american-chemical-society.csl
vignette: >
  %\VignetteIndexEntry{g4dbr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
  ```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

> *Copyright 2020 [Eric Largy](https://github.com/EricLarG4). Licensed under the GPL-3 license.*

# General overview

## Intended and less-intended uses

*g4dbr* is an R package containing the Shiny app *g4db* that is dedicated to the <ins>creation</ins>, <ins>vizualisation</ins>, and <ins>reporting</ins> of curated circular dichroism (CD), ^1^H-NMR, UV-melting and native mass spectrometry (MS) data from oligonucleotides. Although specifically developed for G-quadruplex forming sequences deposited on the PDB, *g4dbr* can be used with any sequence.

Users can either employ the app to visualize a database generated by *g4db*, visualize data pasted into a templated Excel file (provided in the package), and create/edit/complete a *g4db* database from data supplied in said template.

The long-term goal is to provide tools for the robust **deposition** of raw experimental data, and processed data derived from them, while allowing for easy and versatile visualisation and reporting. 

Raw data pasted in the supplied Excel template can be deposited, and visualized in several ways, which are open to other scientists without the need for proprietary software. The approach is two-fold:

### Templated .xlsx file deposition as is

Once pasted into the input template, the data can be deposited as is. It can then be explored natively in Excel or any open-source equivalent. The data is formatted in a non-ambiguous layout, provided it is properly labelled in the header cells. 

The template is also very amenable to pieces of software allowing header cell import/management, such as Origin, in which import scripts can be used.

Of course, the template can be natively imported in the *g4db* app. The advantages over Excel/Origin for this particular application are numerous in terms of both ease and speed of use (data filtering, automated figures, etc.), and functionalities (peak labelling, normalisation/calculation, selective data export, etc.). See the _Main features_ section for more details.

Any data treatment and filtering perfomed within *g4db* is not saved into the .xlsx file. To save this into a new or existing database file, the second approach must be used:

### Rdata file

*g4db* allows exporting selected datasets into an RData (.Rda) file where the data is consolidated and all calculation has already been performed. This leads to faster figure display, smaller file size, and is amenable to host very large dataset (where Excel is limited in row numbers).

The downside of this approach is that it cannot be handled outside of R. Note, however, that *g4db* is not required to open and use the data, it can be natively loaded in R using the `load` function, for instance below for a demo database provided in the package:

```{r load.demo.db, eval=FALSE, include=TRUE}
load(system.file("extdata/demo_database.Rda", package = 'g4dbr'))
```

## Extended scope

*g4dbr* includes a number of functionalities that will be described here within the context of their intended use, but that can be utilized outside of this scope, *i.e.* 

+ automated or semi-automated data filtering, treatment and labelling, 
+ computation of molar extinction coefficient ($\lambda$ = 260 nm) of oligonucleotides (*epsilon.calculator*),
+ UV-melting data treatment (*meltR*),
+ MS data size reduction

## Main features

Below is a list of the main features of *g4dbr*.

+ Vizualisation of CD, UV-melting, ^1^H-NMR and native MS data gathered in a database (.Rda format)
  + Collapsible and tabulated interface
  + Quick and user-friendly data filtering in tables and figures (*e.g.* oligonucleotide, buffer, cation, x-axis range,...)
    + Automated buffer list collection
    + Automated tune and replicate collection
  + Control over the database content, display, and reporting (see below)
+ Robust database creation and edition
  + Data imported from a templated Excel files
  + Selective data importing (by *e.g.* technique/oligo/buffer/data range) 
  + Duplicate detection/suppression
  + Automated deposition date and DOI link generation for traceability purpose
  + Manages replication for MS and UV-melting data
  + Manages tuning for MS data
+ Automated data treatment
  + Conversion of CD to molar ellipticities
  + MS data normalization
  + ^1^H-NMR and MS peak labelling
  + UV-melting data normalization and conversion to folded fraction
+ Custom figures
  + Control over colors, size, and transparency of figures
  + Color palettes adapted to qualitative, sequential, and diverging data
  + Switch between overlaid and paneled figures for quick comparisons
  + Control over variables mapped in paneled figures
  + Automated colour mapping to non-paneled variables
  + Automated figure dimension change to accomodate multiple rows
+ Automated report generation
  + pdf, HTML and Word formats can be selected
  + All data, figure captions, figure sizing, file name, etc. are generated dynamically without user input
+ Open
  + Easy-to-export data tables (practical for standalone data treatment)
  + Import template easy to read in other software

# Installation and setup

## Installation

Install from Github using:

```{r install_online, eval=FALSE, include=TRUE}
install.packages("devtools")
devtools::install_github('g4db-team/g4dbr', build_vignettes = T, build_manual = T)
```

Alternatively, download the .zip archive from GitHub then run:

```{r install, eval=FALSE, include=TRUE}
install.packages("devtools")
devtools::install_local("XXX/g4dbr-master.zip")
```

Where `XXX` is the filepath of the zip archive.

## Setup

Load the package with:

```{r setup}
library(g4dbr)
```

# *g4db*

## Running the app

Only one function must be called to use all functionalities from *g4dbr*:

```{r running, eval=FALSE, include=TRUE}
g4db()
```

This function opens a Shiny app in either the currently used IDE, or a web browser.

## Interface overview

The interface is divided in 3 tabs that can be selected at the top of the screen, and are used to accomplished specific tasks:

+ _database_, to visualize, report, and remove data from a database file.
+ _importR_, to visualize and process raw data, and export all or part of it to a database file,
+ _meltR_, to visualize and treat UV-melting data, and export all or part of it to the a database (via _importR_).

The tabs make use of various sidebars, mainly to perform data importing, filtering, processing, exporting and reporting.

### Figures and tables

In the main area of the interface are the figures and tables, within collapsible and closable boxes, letting the user select what data to display.

All tables are sortable and filterable to assist in exploring rich data sets, and find specific data points rapidly. The data is presented in _long format_, which makes it easier to filter through, and to map variables into figures, because each variable is contained in its own column. Columns can be selectively hidden, and some of the less relevent ones are hidden by default.

Data presented in figures and tables reflects the values given to the different filters. On the contrary, filtering the tables does *not* alter the figures, it is only a mean of accessing and/or exporting a subset of the data. 

All tables can be exported as .csv, .xlsx, or in the clipboard. All columns will be exported, regardless of their visibility in the app.

### Sidebars and panels

#### Left sidebars and panels

Each tab has a sidebar on the left-hand side, which contains a number of tools for data importing, exporting, filtering, and formatting. This _left sidebar_ is collapsible to release some space for figures and tables on smaller screens. Each tab has a specific and independent _left sidebar_, and the values from those _left sidebar_ modifies the data for *all* the content of the tab (and almost always only this tab). Drop-down menus contain *select all/deselect all* buttons for quick data selection. 

Given the amount of menus necessary for the _meltR_ tab, a large portion is hosted in two collapsible and movable "hovering" panels.

The sidebar from the _database_ and _importR_ tabs, and a panel of _meltR_ also contain a color palette selection menu, and submenu for certain palettes having variations. The available palettes include:

 + The well known Brewer palettes that include [qualitative, diverging, and sequential palettes ](https://a2.typepad.com/6a0105360ba1c6970c01b7c7187af2970b-pi),
 + Some [discrete palettes](https://observablehq.com/@d3/working-with-color) from [D3.js](https://d3js.org/), a JavaScript library for producing interactive data visualizations (imported from the `ggsci` package),
 + Several palettes inspired by the colors used by scientific journals/publishers (NPG, AAAS, NEJM, Lancet, JAMA, JCO, etc.; imported from the `ggsci` package).
 
#### Right sidebars
 
Some figure boxes feature a _right sidebar_. They contain filtering and data formatting filters that are applied *only* on the corresponding figure (contrary to the _left sidebars_ that affect entire tabs). These sidebars are collapsible as well, and hidden by default.

## Database tab

The database tab is dedicated to visualizing, exporting, and reporting on the data of a curated database file.

### Database input

The data from a given database must be gathered in a single .Rda file generated in the _importR_ tab. It contains five dataframes: one dedicated to the general oligonucleotide information (`db.info`), and the four other ones to each analytical technique (`db.CD`, `db.NMR`, `db.MS`, `db.UV`). 

*g4db* extracts automatically all the data, but it can also be loaded in the global environment (*i.e.* without using *g4db*) using `load()`. For instance, to load the demo database, run:

```{r load.demo.db.2, eval=FALSE, include=TRUE}
load(system.file("extdata/demo_database.Rda", package = 'g4dbr'))
```

The global environment should now contain five dataframes that can be opended and worked with. When using `g4db()`, the data will be loaded in the package environment and will therefore not appear in the global environment.

### Database use

#### Data loading

Upon opening the database file, the interface should be devoid of data. The first step is to import a database file:

1. Click on _Browse_ in the _Load_ section of the _left sidebar_ (Figure \@ref(fig:dbempty)),
2. Select a .Rda file that has been prepared in _importR_

```{r dbempty, echo=FALSE, fig.cap='Empty database view', out.width='100%'}
knitr::include_graphics('ressources/database_empty.png')
```

The _General information and oligonucleotide selection_ table should now be populated by a list of the oligonucleotides for which the database file contains at least information data (Figure \@ref(fig:dbimport)-1).

The content of this table is controlled by a drop-down menu in the *left sidebar*, and by the oligonucleotide column filter (in that order) (Figure \@ref(fig:dbimport)-2). By default, all oligonucleotides are shown, but none are selected for analytical result display (to avoid wait times when the table content is changed).

```{r dbimport, echo=FALSE, fig.cap='Demo database loaded in the *database* tab: the general oligonucleotide information should be displayed (1). The visible oligonucleotides can be filtered in the table or from the dropdown menu in the *left sidebar* (2). The table (1), and other tables in *g4db*, can be exported (a), their column visibility changed (b), and their content sorted, filtered or searched through (c)', out.width='100%'}
knitr::include_graphics('ressources/database_import.png')
```

#### Data display

To start visualizing data, the _oligonucleotide(s)_ of interest must be selected from the *General information* table, by clicking on one or several rows (Figure \@ref(fig:dbselection)-1). Clicking again on a row deselects it.

The *CD*, *NMR* and *UV-melting* data should now be displayed (Figures \@ref(fig:dbselection)-2 and \@ref(fig:dbmassplot)-1). By default, the data aquired for all *buffer* conditions (i.e. all *cation* + *electrolyte*) are shown, but it can be restricted to only certan *buffers*, *electrolytes* or *cations*, using the menus from the *left sidebar* (Figure \@ref(fig:dbselection)-3). Individual *cation* and *electrolyte* selections supersede the *buffer* selection. For instance, if the buffers "TMAA + KCl" and "Kp + KCl" are selected, but the "Kp" electrolyte is excluded, then only "TMAA + KCl" will effectively be selected.

Note that the *buffers*, *electrolytes* and *cations* are not a static list, but are automatically collected from the _CD_ and _UV-melting_ data. It is therefore important to keep their naming consistent across the entire database.

```{r dbselection, echo=FALSE, fig.cap='Database data display: both oligonucleotides have been selected (1). Their data is displayed (2) but was buffer-filtered (3): only KCl-containing solutions are selected (a). Using the *right sidebar*, the *CD* data was panelled by *oligonucleotide* (b)', out.width='100%'}
knitr::include_graphics('ressources/database_selection.png')
```

To also display MS data (\@ref(fig:dbmassplot)-2), the *Plot MS* button must be used \@ref(fig:dbmassplot)-3. This avoid long refresh times when selecting oligonucleotides. Any change in the *oligonucleotide*, *buffer*, *tunes*, *replicates*, and *m/z* selections will only be effective if the figure is replotted.

```{r dbmassplot, echo=FALSE, fig.cap='Database data display: UV-melting (1) and native MS (2) display. To display the MS data, the *Plot MS* button must be used (3)', out.width='100%'}
knitr::include_graphics('ressources/database_massplot.png')
```
For all these analytical methods, all data points are gathered in table, collapsed by default. These data points can be sorted, filtered, and exported in .xlsx or .csv files, or copied in the clipboard. Again, filtering data in the tables does **not** affects the figures, only the *left* and *right sidebars* do.

### Data content and customization

#### General information
The general information table contains nineteen fields, ten of which are shown by default.

#### Circular dichroism


#### NMR


#### UV-melting


#### Native MS


### Reporting

## importR tab

## meltR tab

## Consulting a database

### Database architecture



## Importing data

### Templated-Excel file

# Other functions and reference files

## epsilon.calculator

### Principles

`epsilon.calculator` relies on the 'traditional' format of the nearest-neighbor model for extinction coefficient calculation, applied at 260 nm.[@Cantor1970; @Tataurov2008]

$$\epsilon_{260nm} = \sum_{i=1}^{N_b - 1}\epsilon_{i, i+1} - \sum_{i=2}^{N_b - 1}\epsilon_{i}$$

To that effect, it uses `epsilondb`, a database of reference $\epsilon_{260 nm}$ contributions from the individual nucleobases, and couples of nucleobases (neighboring effects):

```{r epsilon.db}
epsilondb
```

epsilon.db is contained within the `[installpath]/data/Rdata.rds` file after the package is built. The value may be modified from the `[installpath]/extdata/referencedb.xlsx` but requires to rebuild the package.

### Code

The code of `epsilon.calculator` is contained in `R/EpsilonCalc.R`

First, the list of nucleobases and their nearest 3' neighbour are extracted from the user-supplied sequence (here 5'-GCAT-3'):

```{r sequence.read}
library(stringr)
library(tidyverse)

#sequence provided by the user
sequence <- 'GCAT'

#initialization of result data frame
epsilon.calc <- data.frame()
buffer <- data.frame()
result <- data.frame()

#extraction of individual bases and their 3' nearest neighbor
for (i in 1:str_length(sequence)) {
  buffer <- data.frame(position = i,
                       nucleo = substr(sequence, i, i),
                       nn = substr(sequence, i+1, i+1)
  )
  epsilon.calc <- rbind(epsilon.calc, buffer)
}

epsilon.calc
```

Their contribution are then attributed by matching their one letter code to the database, and both the 5' and 3' ends have their individual contributions set to zero.

```{r contribution}
#attribution of individual and nearest neighbor contributions
  epsilon.calc <- epsilon.calc %>%
    mutate(
      indiv.base.cont = case_when( #individual
        nucleo == 'G' ~ epsilondb$epsilon[epsilondb$base == 'G'],
        nucleo == 'C' ~ epsilondb$epsilon[epsilondb$base == 'C'],
        nucleo == 'T' ~ epsilondb$epsilon[epsilondb$base == 'T'],
        nucleo == 'A' ~ epsilondb$epsilon[epsilondb$base == 'A']
      ),
      nn.cont = case_when( #nearest neighbor
        nucleo == 'G' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'G'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'G'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'G'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'G']
        ),
        nucleo == 'C' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'C'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'C'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'C'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'C']
        ),
        nucleo == 'T' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'T'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'T'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'T'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'T']
        ),
        nucleo == 'A' ~ case_when(
          nn == 'G' ~ epsilondb$Gcorr[epsilondb$base == 'A'],
          nn == 'C' ~ epsilondb$Ccorr[epsilondb$base == 'A'],
          nn == 'T' ~ epsilondb$Tcorr[epsilondb$base == 'A'],
          nn == 'A' ~ epsilondb$Acorr[epsilondb$base == 'A']
        )
      )
    )

  epsilon.calc$indiv.base.cont[1] = 0 #attributes 0 to the first nucleobase individual contribution
  epsilon.calc$indiv.base.cont[str_length(sequence)] = 0 #attributes 0 to the last nucleobase individual contribution

epsilon.calc
```

Finally, the sum of individual contributions are subtracted from the nearest neighbor contributions:

```{r result.epsilon}
#sum of indiv cont subtracted from sum of nn cont.
result <- sum(epsilon.calc$nn.cont, na.rm = T) - sum(epsilon.calc$indiv.base.cont, na.rm = T)
result
```


### Use

`epsilon.calculator` computes the molar extinction coefficient at 260 nm of oligonucleotides from their sequences. So far, it only works for DNA oligonucleotides, using the four canonical nucleotides.

Below is an example for a single sequence:

```{r eps.DNA}
epsilon.calculator("GGGTTAGGGTTAGGGTTAGGG")
```

The sequence must be provided as a string, and **must** be written with upper case letters (to allow the implementation of RNA calculation in the future):

```{r eps.RNA}
epsilon.calculator("gggttagggttagggttaggg")
```

`epsilon.calculator` can be applied on a list of sequence (here, `oligo.list`) using the base function `lapply`:

```{r eps.list}
oligo.list <- c('oligo name 1' = 'GGGTTAGGGTTAGGGTTAGGG', 'oligo name 2' = 'TGGGGT', 'oligo name 3' = 'GCAT', 'oligo name 4' = 'TACG')

epsilon.list <- lapply(oligo.list, epsilon.calculator)

epsilon.list
```

or on a data frame (here, `df`) to directly associate the results to other variables, as is performed within `g4db`.

```{r eps.df}
df <- data.frame(
  oligo = c('name 1', 'name 2', 'name 3', 'name 4'),
  something = c('a', 'b', 'c', 'd'),
  sequence = c('GGGTTAGGGTTAGGGTTAGGG', 'TGGGGT', 'GCAT', 'TACG')
)

df$epsilon <- lapply(df$sequence, epsilon.calculator)

df
```






# References



